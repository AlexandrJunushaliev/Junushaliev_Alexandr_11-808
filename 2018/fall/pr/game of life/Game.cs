namespace GameOfLife
{
    /* Реализуйте игру в жизнь на прямоугольном конечном поле.
     
     На каждом ходе клетка меняет свое состояние по таким правилам:
     1. Если у нее менее 2 живых соседей или более трех живых — она становится мертвой (false).
     2. Если ровно 3 живых соседа, то клетка становится живой (true)
     3. Если ровно 2 живых соседа, то клетка сохраняет своё состояние.

     У каждой неграничной клетки есть 8 соседей (в том числе по диагонали)

    Работу над игрой постройте итеративно в стиле TDD:
        1. Сначала напишите какой-нибудь простейший тест в соседнем файле GameTest.cs. Тест должен быть красным.
        То есть должен проверять ещё нереализованное требование.
        2. Только потом напшишите простейшую реализацию, которая делает тест зеленым. 
        Не старайтесь реализовать всю логику, просто сделайте тест зеленым как можно быстрее.
        3. Повторяйте процесс, пока ещё можете придумать новые красные тесты.

     На каждый шаг (тест и реализация) у вас должно уходить не более 5 минут.
     Если вы не успели поднять тест за 5 минут — удалите этот тест и придумайте тест попроще.
     Засекайте время таймером на телефоне.

     После каждого шага (тест или реализация) меняйте активного человека за клавиатурой.

     Начните с простейших тестов. 

     Проект настроен так, что при каждой сборке запускаются все тесты и отчет выводится на консоль
    */
    public class Game
    {
        public static bool[,] NextStep(bool[,] field)
        {
            var field1 = new bool[field.GetLength(0),field.GetLength(1)];
            for (var i=0;i<field.GetLength(0);i++)
            {
                for (var j = 0; j < field.GetLength(1); j++)
                {
                    field1[i, j] = CheckAlive(field, i, j);
                }
            }

            return field1;
        }
        private static bool CheckAlive(bool[,] field, int i, int j)
        {
            int count = 0;
            var length0 = field.GetLength(0);
            var length1 = field.GetLength(1);
            if (j > 0 && field[i, j - 1]) count++;
            if (j < length1 - 1 && field[i, j + 1]) count++;
            if (i > 0)
            {
                if (field[i - 1, j]) count++;
                if (j > 0 && field[i - 1, j - 1]) count++;
                if (j < length1 - 1 && field[i - 1, j + 1]) count++;
            }
            if (i < length0 - 1)
            {
                if (field[i + 1, j]) count++;
                if (j > 0 && field[i + 1, j - 1]) count++;
                if (j < length1 - 1 && field[i + 1, j + 1]) count++;
            }
            if (count == 2) return field[i,j];
            else if (count == 3) return true;
            else return false;
        }
    }
}